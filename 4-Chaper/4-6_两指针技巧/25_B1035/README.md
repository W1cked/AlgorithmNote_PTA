# B1035 插入与归并

### 输入样例 1：

```in
10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0  
```

### 输出样例 1：

```out
Insertion Sort
1 2 3 5 7 8 9 4 6 0 
```

### 输入样例 2：

```in
10
3 1 2 8 7 5 9 4 0 6
1 3 2 8 5 7 4 9 0 6   
```

### 输出样例 2：

```out
Merge Sort
1 2 3 8 4 5 7 9 0 6
```

---

## 思路

很明显，如果不是插入排序，就一定是归并排序。

我们先探测第2行的数列是不是插入排序所形成的。如果从头探测到尾均不符合插入排序的特点，那么我们就按归并排序的情况处理。

我们观察插入排序，可以发现一些特点，以样例1为example：

- 从1开始计数。前5项是从小到大的**有序**数列；
- 第6~第10项**和原数列是一样的**；

由此观之，我们可以用2个顺序执行的while循环来判断这个数列是不是插入排序形成的。步骤如下，设 number 为数列元素个数：

1. while(i < number && halftSort[i] <= halfSort[i + 1]) ，则 i++;
2. while(i < number && (halfSort[i + 1] == origin[i + 1]))，则i++;
3. 如果 i != number - 1，则该数列是由归并排序形成的。

判断完是什么类型的排序后，就可以借用sort()函数来完成下一步排序。

---

- 插入排序

  我们只需要找到原来给的有序数列有多长，直接长度加1继续排序后输出即可。

- 归并排序

  1. 从origin数组一步步模拟归并排序
  2. 每次排序后用一个自定义的函数来判断和题目给出的是不是一样的
  3. 如果是一样的，那就再模拟一次归并排序后输出